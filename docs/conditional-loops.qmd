---
title: "conditional_loops"
format: html
editor: visual
execute:
    warning: FALSE
---

```{r}
library(tidyverse)
library(janitor)
library(here)
```

#### **Task 1**

Create an object called `pm2_5` with a value of 48 (representing Particulate Matter 2.5, an indicator for air quality, in μgm3���3 (see more about PM2.5 [**here**](https://www3.epa.gov/region1/airquality/pm-aq-standards.html)).

Write an `if - else if - else` statement that returns \"Low to moderate risk\" if `pm2_5` (for Particulate Matter 2.5) is less than 100, \"Unhealthy for sensitive groups\" if PM 2.5 is 100 \<= pm2_5 \< 150, and \"Health risk present\" if PM 2.5 is \>= 150.

Test by changing the value of your pm2_5 object and re-running your statement to check.

```{r}
pm2_5 <- 48

if (pm2_5 < 100) {
  print("Low to moderate risk")
} else if (pm2_5 >= 100 & pm2_5 < 150) {
  print("Unhealthy for sensitive groups")
} else if (pm2_5 >= 150) {
  print("Health risk is presesnt")
}
```

#### **Task 2**

Store the string \"blue whale\" as an object called `species`. Write an if statement that returns \"You found a whale!\" if the string \"whale\" is detected in species, otherwise return nothing. Test by changing the species string & re-running to see output.

```{r}
species <- "blue whale"

if (species == "blue whale") {
  print(paste("You found a whale!"))
} else {
  print("nothing")
}
```

#### **Task 3**

Store the base price of a burrito as `base_burrito` with a value of 6.50. Store `main_ingredient` with a starting string of \"veggie.\" Write a statement that will return the price of a burrito based on what a user specifies as \"main_ingredient\" (either \"veggie\", \"chicken\" or \"steak\") given the following:

-   A veggie burrito is the cost of a base burrito

-   A chicken burrito costs 3.00 more than a base burrito

-   A steak burrito costs 3.25 more than a base burrito

```{r}
base_burrito <- 6.5

main_ingredient <- "veggie"

veggie_burrito <- base_burrito
chicken <- base_burrito + 3
steak <- base_burrito + 3.5

if (main_ingredient == "veggie") {
  print(paste(veggie_burrito))
} else if (main_ingredient == "chicken") {
  print(paste(chicken))
} else if (main_ingredient == " steak") {
  print(paste(steak))
}
```

### **For loops**

*Complete each of the following in a separate code chunk.*

#### **Task 4**

Create a new vector called `fish` that contains the values `8, 10, 12, 23` representing counts of different fish types in a fish tank (goldfish, tetras, guppies, and mollies, respectively). Write a for loop that iterates through `fish`, and returns what proportion of total fish in the tank are that species. Assume that these counts represent all fish in the tank.

```{r}
## this answer is wrong
fish <- c("goldfish" = 3, "tetras" = 10, "guppies" = 12, "mollies" = 23)

for (i in fish) {
  prop_total = (fish[i] / sum(fish[i]))
}
```

#### **Task 5**

There is an existing vector in R called `month.name` that contains all month names (just ry running `month.name` in the Console to check it out). **Write a for loop** that iterates over all months in `month.name` and prints \"January is month 1,\" \"February is month 2\", etc.

**Hint:** you can index values in the `month.name` vector just like you would any other vector (e.g., try running `month.name[5]`).

```{r}
month.name

for (i in seq_along(month.name)) {
  print(paste(month.name[i], "is month", i))
}
```

## **Part 2. Real data**

*You will complete Part 3 in a separate .qmd.*

Explore this [**data package**](https://portal.edirepository.org/nis/mapbrowse?packageid=knb-lter-arc.10341.5) from EDI, which contains a \"Data file describing the biogeochemistry of samples collected at various sites near Toolik Lake, North Slope of Alaska\". Familiarize yourself with the metadata (particularly, View full metadata \> expand \'Data entities\' to learn more about the variables in the dataset).

**Citation:** Kling, G. 2016. Biogeochemistry data set for soil waters, streams, and lakes near Toolik on the North Slope of Alaska, 2011. ver 5. Environmental Data Initiative. [**https://doi.org/10.6073/pasta/362c8eeac5cad9a45288cf1b0d617ba7**](https://doi.org/10.6073/pasta/362c8eeac5cad9a45288cf1b0d617ba7)

1.  Download the CSV containing the Toolik biogeochemistry data

2.  Take a look at it - how are missing values stored? Keep that in mind.

3.  Drop the CSV into your data folder of your project

4.  Create a new Quarto document, save in docs as `toolik_chem.qmd`

5.  Attach the `tidyverse`, `here`, and `janitor` packages in your setup code chunk

6.  Read in the data as `toolik_biochem`. Remember, you\'ll want to specify here how `NA` values are stored. Pipe directly into `janitor::clean_names()` following your import code to get all column names into lower snake case.

7.  Create a subset of the data that contains only observations from the \"Toolik Inlet\" site, and that only contains the variables (columns) for pH, dissolved organic carbon (DOC), and total dissolved nitrogen (TDN) (**hint:** see `dplyr::select()`). Store this subset as `inlet_biochem`. Make sure to look at the subset you\'ve created.

8.  Find the mean value of each column in `inlet_biochem` 3 different ways:

```{=html}
<!-- -->
```
1.  Write a for loop from scratch to calculate the mean for each

2.  Use *one other method* (e.g. `apply`, `across`, or `purrr::map_df`) to find the mean for each column.

```{r}
toolik_biochem <- read_csv(here("data", "2011_Kling_Akchem.csv"), na = ".") %>% 
  clean_names()
  
inlet_biochem <- toolik_biochem %>% 
  select(site, p_h, doc_u_m, tdn_u_m)

# calculate mean values in 3 different ways

#first way
mean_inlet_biochem_1 <- inlet_biochem %>% 
  group_by(site) %>% 
  summarize(mean_ph = mean(p_h, na.rm = TRUE),
            mean_doc = mean(doc_u_m, na.rm = TRUE),
            mean_tdn = mean(tdn_u_m, na.rm = TRUE))

#second way
mean_inlet_biochem_2 <- inlet_biochem %>% 
  group_by(site)

#third way


#for loop - prob wrong?
for (i in seq_along(inlet_biochem)) {
  if (is.numeric(inlet_biochem[i])) {
    inlet_biochem_mean <- mean(inlet_biochem[i], na.rm = TRUE)
    print(inlet_biochem_mean)
  }
}


```

1.  Use *one other method* (e.g. `apply`, `across`, or `purrr::map_df`) to find the mean for each column.

```{r}
apply(inlet_biochem$p_h, 2, mean)
```

### **Save, stage, commit, pull, push!**

## **END Day 3 activities**
